# Move-семантика

К настоящему времени понятно, как можно создавать объект с помощью копирования и размещать его в нужном месте. С помощью доступных инструментов уже можно добиваться корректного поведения программы. Но как насчет эффективности? 

## Мотивация move-семантики и проблемы копирования

### Проблема первая
Пусть реализован контейнер, обладающий интерфейсом вектора с учетом лишь семантики копирования. 

```cpp
void push_back(const T& value) {
    if (sz == cap) reserve(2 * cap);
    AllocTraits::construct(alloc, arr + sz, value);
    ++sz;
}
```

Сколько раз вызывается конструктор копирования?

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<std::vector> v;
    v.push_back(std::string("abc"));
}
```

Ответ: дважды. Сперва необходимо создать временный объект-копию, затем создать для него ещё одну копию.

### Проблема вторая
реаллокация вектора. Для всех элементов придется вызывать копирование.

### Проблема третья

```cpp
#include <iostream>
#include <vector>

template <typename T>
void swap(T& x, T& y) {
    T t = x;
    x = y;
    y = t;
}

int main() {}

```

Какие проблемы у функции swap для нетривиальных типов?
Ответ: избыточное копирование. Перевыделение ресурсов произойдет трижды!


### Проблема четвертая

```cpp
template <typename T>
T createObject(...) {
    //...
    return object;
}

int main() {
    MyHeavyType object = createObject();
}
```

пока всё хорошо... 
Но что получится, если передать объект в фунцию f, которая будет каким-то образом его изменит?

```cpp
template <typename T>
T createObject(...) {
    // some actions
    return object;
}

int main() {
    f(createObject());
}
```

Снова произойдет копирование. (По сути это проблема 1)

Кажущееся решение: emplace_back (24:00)

Фактическое решение: не копирование, а перемещение данных! Оно же move-семантика. 
Сперва будем использовать ее как магический инструмент, а затем разберемся в деталях механики.

## Функция std::move

Синтаксис достаточно специфический, потому что одна из целей &ndash; сохранить максимум обратной совместимости с уже написанным кодом.

Первое магическое заклинание. 

```cpp
#include <iostream>
#include <vector>

template <typename T>
void swap(T& x, T& y) {
    T t = std::move(x);
    x = std::move(y);
    y = std::move(t);
}
```

В чем отличие кода от описанной выше проблемы swap? 

<details><summary>code snippet</summary>
<p>

```cpp
#include <iostream>
#include <vector>

template <typename T>
void swap(T& x, T& y) {
    T t = std::move(x);
    x = std::move(y);
    y = std::move(t);
}

int main() {
    std::string s = "abcdf";
    std::cout << s.size() << '\n';
    
    std::string ss = std::move(s);
    std::cout << ss.size() << ' ' << s.size() << '\n';

}
```
</p>
</details>

Функция std::move не портит объект сама по себе. 
```cpp
std::move(obj); // не изменяет объект и ничего не перемещает
```

При успешном перемещении объект остается пустым, но консистентным! 

Удобно представлять себе вызов std::move как указание компилятору на возможность перемещения содержимого объекта-параметра. Чтобы перемещение произошло успешно, необходимо, чтобы контекст требовал перемещения и объект поддерживал эту семантику.

## Поддержка move-семантики для собственных классов

Move-конструктор, move-присваивание

```cpp

```

Правило пяти. Если определен один из методов: конструктор копирования,  оператор присваивания, перемещающий конструктор, перемещающий оператор присваивания, деструктор, то необходимо определить все остальные функции.

https://en.cppreference.com/w/cpp/language/rule_of_three

43:49