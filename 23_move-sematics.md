# Move-семантика

К настоящему времени понятно, как можно создавать объект с помощью копирования и размещать его в нужном месте. С помощью доступных инструментов уже можно добиваться корректного поведения программы. Но как насчет эффективности? 

## Мотивация move-семантики и проблемы копирования

### Проблема первая
Пусть реализован контейнер, обладающий интерфейсом вектора с учетом лишь семантики копирования. 

```cpp
void push_back(const T& value) {
    if (sz == cap) reserve(2 * cap);
    AllocTraits::construct(alloc, arr + sz, value);
    ++sz;
}
```

Сколько раз вызывается конструктор копирования?

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<std::vector> v;
    v.push_back(std::string("abc"));
}
```

Ответ: дважды. Сперва необходимо создать временный объект-копию, затем создать для него ещё одну копию.

### Проблема вторая
реаллокация вектора. Для всех элементов придется вызывать копирование.

### Проблема третья

```cpp
#include <iostream>
#include <vector>

template <typename T>
void swap(T& x, T& y) {
    T t = x;
    x = y;
    y = t;
}

int main() {}

```

Какие проблемы у функции swap для нетривиальных типов?
Ответ: избыточное копирование. Перевыделение ресурсов произойдет трижды!


### Проблема четвертая

```cpp
template <typename T>
T createObject(...) {
    //...
    return object;
}

int main() {
    MyHeavyType object = createObject();
}
```

пока всё хорошо... 
Но что получится, если передать объект в фунцию f, которая будет каким-то образом его изменит?

```cpp
template <typename T>
T createObject(...) {
    // some actions
    return object;
}

int main() {
    f(createObject());
}
```

Снова произойдет копирование. (По сути это проблема 1)

Кажущееся решение: emplace_back (24:00)

Фактическое решение: не копирование, а перемещение данных! Оно же move-семантика. 
Сперва будем использовать ее как магический инструмент, а затем разберемся в деталях механики.

## Функция std::move

Синтаксис достаточно специфический, потому что одна из целей &ndash; сохранить максимум обратной совместимости с уже написанным кодом.

Первое магическое заклинание. 

```cpp
#include <iostream>
#include <vector>

template <typename T>
void swap(T& x, T& y) {
    T t = std::move(x);
    x = std::move(y);
    y = std::move(t);
}
```

В чем отличие кода от описанной выше проблемы swap? 

<details><summary>code snippet</summary>
<p>

```cpp
#include <iostream>
#include <vector>

template <typename T>
void swap(T& x, T& y) {
    T t = std::move(x);
    x = std::move(y);
    y = std::move(t);
}

int main() {
    std::string s = "abcdf";
    std::cout << s.size() << '\n';
    
    std::string ss = std::move(s);
    std::cout << ss.size() << ' ' << s.size() << '\n';

}
```
</p>
</details>

Функция std::move не портит объект сама по себе. 
```cpp
std::move(obj); // не изменяет объект и ничего не перемещает
```

При успешном перемещении объект остается пустым, но консистентным! 

Удобно представлять себе вызов std::move как указание компилятору на возможность перемещения содержимого объекта-параметра. Чтобы перемещение произошло успешно, необходимо, чтобы контекст требовал перемещения и объект поддерживал эту семантику.

## Поддержка move-семантики для собственных классов

Move-конструктор, move-присваивание, правило пяти


### Move-конструктор

Имеет неожиданную сигнатуру. В качестве параметра принимает не значение и не привычную ссылку, а нечто третье. По сути это тоже ссылка, но специального типа.


```cpp
class String {
    // ...
    
    // move-constructor
    String(String&& s) {
        str = s.str;
        sz = s.sz;
        s.str = nullptr;
        s.sz = 0;
    }
}
```

Работа move-конструктора состоит из 2х этапов. Он должен забрать ресурсы у объекта-аргумента, а затем восстановить его консистентное состояние. В примере, происходит захват указателя для s, а затем поля s приводятся к пустому (но валидному!) состоянию.

Чуть более красивая реализация

```cpp
class String {
    // ...
    
    // move-constructor
    String(String&& s): sz(s.sz), str(s.str) {        
        s.str = nullptr;
        s.sz = 0;
    }
}
```

### Move-присваивание

Move-присваивание выглядит немного избыточным. Но позволяет сохранять консистентность объектов

```cpp
class String {
    // ...

    void swap(String& s) {
        std::swap(sz, s.sz);
        std::swap(str, s.str);
    }

    // move-присваивание
    String& operator=(String&& s) {
        String new_s = std::move(s); // вызывает move-конструктор, опустошает s
        swap(new_s);                 // переносит данные в this
        return *this;                // возвращает this, удаляет new_s
    }
}
```

Вопросы: 
1) чему равна s на выходе? 
2) чему равна new_s на выходе?
3) зачем вообще создавать new_s, не лучше ли сразу swap(s)?


Ответ на 3: на самом деле можно, достаточно: очистить свою строку, забрать поля у строки-аргумента, очистить поля строки-аргумента.


### Автоматическая генерация

Можно указать компилятору, что перемещающие операторы должны быть сгенерированы по умолчанию

```cpp
class String {
    // ...
        
    String(String&& s) = default;
    String& operator=(String&& s) = default;

}
```
Но на практике этот способ зачастую ведет к некорректному поведению. Дело в том, что move-операторы по-умолчанию стараются переместить все поля как простые типы. Поэтому указали будут перемещены, но не обнулены!

https://en.cppreference.com/w/cpp/language/move_constructor

```cpp
class String {
    // пример некорректного поведения?
}
```

Поэтому здесь следует пользоваться правилом пяти. Если определен один из методов: конструктор копирования,  оператор присваивания, перемещающий конструктор, перемещающий оператор присваивания, деструктор, то необходимо определить все остальные функции.

https://en.cppreference.com/w/cpp/language/rule_of_three


### Решение исходных проблем

Имея в руках инструмент std::move, можно подумать о том, как исправить проблему избыточного копирования. Как это сделать для push_back?

```cpp
void push_back(const T& value) {
    if (sz == cap) reserve(2 * cap);
    AllocTraits::construct(alloc, arr + sz, value);
    ++sz;
}
```

<details><summary>code snippet</summary>
<p>
Нужно перегрузить метод, добавив возможность использовать move-семантику для объектов, которые это умеют

```cpp
void push_back(const T& value) {
    if (sz == cap) reserve(2 * cap);
    AllocTraits::construct(alloc, arr + sz, value);
    ++sz;
}

void push_back(T&& value) {
    if (sz == cap) reserve(2 * cap);
    AllocTraits::construct(alloc, arr + sz, std::move(value));
    ++sz;
}
```
</p>
</details>

## Нефрмальное определение lvalue и rvalue

Какие lvalue не может стоять слева от оператора присваивания? 
Ответ: const-объекты, объекты, у которых не определен оператор присваиваивания.

Какие rvalue могут стоять слева от оператора присваивания? 
Ответ: когда для объекта генерируется временное представление, с которым необходимо работать.

Немного квантовой запутанности.

1) lvalue и rvalue являются синтаксическими понятиями и характеризуют выражения
2) lvalue и rvalue связаны не с типами объектов, а с контекстом, в котором объекты используются

Вопросы "является или объект lvalue/rvalue?", "является или тип lvalue/rvalue?" не имеют смысла. 





